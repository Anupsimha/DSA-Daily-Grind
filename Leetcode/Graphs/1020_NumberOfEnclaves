// Approach : DFS
// Time Complexity : O(N * M)
// Space Complexity : O(N * M)  , Due to recursion stack space


// int m , n;
// vector<vector<int>> directions = {{1 , 0} , {-1 , 0} , {0 , 1} , {0 , -1}};

// void dfs(vector<vector<int>>& grid, int i, int j) {
//     if (i < 0 || i >= m || j < 0 || j >= n) return;
//     if (grid[i][j] == 0) return;

//     grid[i][j] = 0; 

//     for (auto &d : directions) {
//         dfs(grid, i + d[0], j + d[1]);
//     }
// }

// int numEnclaves(vector<vector<int>>& grid) {
//     m = grid.size();
//     n = grid[0].size();

//     for (int j = 0; j < n; j++) {
//         if (grid[0][j] == 1) dfs(grid, 0, j);
//         if (grid[m-1][j] == 1) dfs(grid, m-1, j);
//     }

//     for (int i = 1; i < m-1; i++) {
//         if (grid[i][0] == 1) dfs(grid, i, 0);
//         if (grid[i][n-1] == 1) dfs(grid, i, n-1);
//     }

//     int count = 0;
//     for (int i = 0; i < m; i++) {
//         for (int j = 0; j < n; j++) {
//             if (grid[i][j] == 1)
//                 count++;
//         }
//     }

//     return count;
// }


                 // or //

// int m , n;
// vector<vector<int>> directions = {{1 , 0} , {-1 , 0} , {0 , 1} , {0 , -1}};

// bool dfs(vector<vector<int>>& grid, int i, int j, vector<vector<bool>>& vis, int &count) {
//     if (i < 0 || i >= m || j < 0 || j >= n)
//         return false;

//     if (grid[i][j] == 0)
//         return true;

//     if (vis[i][j])
//         return true;

//     vis[i][j] = true;
//     count++;

//     bool isEnclosed = true;

//     for (auto &dir : directions) {
//         int ni = i + dir[0];
//         int nj = j + dir[1];

//         bool res = dfs(grid, ni, nj, vis, count);
//         if (!res)
//             isEnclosed = false;
//     }

//     return isEnclosed;
// }

// int numEnclaves(vector<vector<int>>& grid) {
//     m = grid.size();
//     n = grid[0].size();

//     vector<vector<bool>> vis(m, vector<bool>(n, false));
//     int total = 0;

//     for (int i = 0; i < m; i++) {
//         for (int j = 0; j < n; j++) {
//             if (grid[i][j] == 1 && !vis[i][j]) {
//                 int count = 0;

//                 bool enclosed = dfs(grid, i, j, vis, count);
//                 if (enclosed)
//                     total += count;
//             }
//         }
//     }

//     return total;
// }             






// Approach : Using BFS
// Time Complexity : O(N * M)
// Space Complexity : O(N * M)


// int numEnclaves(vector<vector<int>>& grid) {
//     int m = grid.size();
//     int n = grid[0].size();

//     queue<pair<int,int>> q;

//     // Put all boundary land cells into queue
//     for (int j = 0; j < n; j++) {
//         if (grid[0][j] == 1) {
//             q.push({0, j});
//             grid[0][j] = 0;
//         }
//         if (grid[m-1][j] == 1) {
//             q.push({m-1, j});
//             grid[m-1][j] = 0;
//         }
//     }

//     for (int i = 1; i < m-1; i++) {
//         if (grid[i][0] == 1) {
//             q.push({i, 0});
//             grid[i][0] = 0;
//         }
//         if (grid[i][n-1] == 1) {
//             q.push({i, n-1});
//             grid[i][n-1] = 0;
//         }
//     }

//     vector<vector<int>> dir = {{1,0},{-1,0},{0,1},{0,-1}};

//     // Remove all land reachable from boundary
//     while (!q.empty()) {
//         auto [i, j] = q.front(); 
//         q.pop();

//         for (auto &d : dir) {
//             int ni = i + d[0];
//             int nj = j + d[1];

//             if (ni >= 0 && ni < m && nj >= 0 && nj < n && grid[ni][nj] == 1) {
//                 grid[ni][nj] = 0;
//                 q.push({ni, nj});
//             }
//         }
//     }

//     int count = 0;
//     for (int i = 0; i < m; i++) {
//         for (int j = 0; j < n; j++) {
//             if (grid[i][j] == 1)
//                 count++;
//         }
//     }

//     return count;
// }